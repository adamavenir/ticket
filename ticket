#!/usr/bin/env bash
set -euo pipefail

# ticket - minimal ticket system with dependency tracking
# Stores markdown files with YAML frontmatter in .tickets/

TICKETS_DIR=".tickets"

# Prefer ripgrep if available, fall back to grep
if command -v rg &>/dev/null; then
    _grep() { rg "$@"; }
else
    _grep() { grep "$@"; }
fi

# Portable sha256 (Linux: sha256sum, macOS: shasum -a 256)
if command -v sha256sum &>/dev/null; then
    _sha256() { sha256sum; }
else
    _sha256() { shasum -a 256; }
fi

# Portable ISO date (GNU date supports -Iseconds, BSD date does not)
_iso_date() {
    date -u +%Y-%m-%dT%H:%M:%SZ
}

# Portable sed -i (BSD requires -i '', GNU uses -i)
_sed_i() {
    local file="$1"
    shift
    local tmp="${file}.tmp.$$"
    sed "$@" "$file" > "$tmp" && mv "$tmp" "$file"
}

# Generate ticket ID from directory name + timestamp hash
generate_id() {
    local dir_name
    dir_name=$(basename "$(pwd)")

    # Extract first letter of each hyphenated/underscored segment
    local prefix
    prefix=$(echo "$dir_name" | sed 's/[-_]/ /g' | awk '{for(i=1;i<=NF;i++) printf substr($i,1,1)}')

    # Fallback to first 3 chars if no segments
    [[ -z "$prefix" ]] && prefix="${dir_name:0:3}"

    # 4-char hash from timestamp + PID for entropy
    local hash
    hash=$(echo "$$$(date +%s)" | _sha256 | head -c 4)

    echo "${prefix}-${hash}"
}

# Ensure tickets directory exists
ensure_dir() {
    mkdir -p "$TICKETS_DIR"
}

# Update the 'updated' timestamp on a ticket
touch_updated() {
    local file="$1"
    update_yaml_field "$file" "updated" "$(_iso_date)"
}

# Get ticket file path (supports partial ID matching)
ticket_path() {
    local id="$1"
    local exact="$TICKETS_DIR/${id}.md"

    if [[ -f "$exact" ]]; then
        echo "$exact"
        return 0
    fi

    # Try partial match (search subdirectories too)
    local matches
    matches=$(find "$TICKETS_DIR" -name "*${id}*.md" 2>/dev/null | head -3)
    local count
    count=$(echo "$matches" | _grep -c . || true)

    if [[ "$count" -eq 1 ]]; then
        echo "$matches"
        return 0
    elif [[ "$count" -gt 1 ]]; then
        echo "Error: ambiguous ID '$id' matches multiple tickets:" >&2
        echo "$matches" | sed 's|.*/||; s|\.md$||' >&2
        return 1
    else
        echo "Error: ticket '$id' not found" >&2
        return 1
    fi
}

# Extract YAML field value
yaml_field() {
    local file="$1"
    local field="$2"
    sed -n '/^---$/,/^---$/p' "$file" | (_grep "^${field}:" || true) | sed "s/^${field}: *//"
}

# Update YAML field
update_yaml_field() {
    local file="$1"
    local field="$2"
    local value="$3"

    if _grep -q "^${field}:" "$file"; then
        _sed_i "$file" "s/^${field}:.*/${field}: ${value}/"
    else
        # Insert before closing --- using awk
        local tmp="${file}.tmp.$$"
        awk -v field="$field" -v value="$value" '
            BEGIN { in_front=0; inserted=0 }
            /^---$/ {
                if (in_front && !inserted) {
                    print field ": " value
                    inserted=1
                }
                in_front = !in_front
            }
            { print }
        ' "$file" > "$tmp" && mv "$tmp" "$file"
    fi
}

cmd_create() {
    ensure_dir

    local title="" description="" design="" acceptance=""
    local priority=2 issue_type="task" assignee="" external_ref=""
    local custom_id="" dir=""

    # Default assignee to git user.name if available
    assignee=$(git config user.name 2>/dev/null || true)

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--description) description="$2"; shift 2 ;;
            --design) design="$2"; shift 2 ;;
            --acceptance) acceptance="$2"; shift 2 ;;
            -p|--priority) priority="$2"; shift 2 ;;
            -t|--type) issue_type="$2"; shift 2 ;;
            -a|--assignee) assignee="$2"; shift 2 ;;
            --external-ref) external_ref="$2"; shift 2 ;;
            --id) custom_id="$2"; shift 2 ;;
            --dir) dir="$2"; shift 2 ;;
            -*) echo "Unknown option: $1" >&2; return 1 ;;
            *) title="$1"; shift ;;
        esac
    done

    title="${title:-Untitled}"
    local id
    if [[ -n "$custom_id" ]]; then
        id="$custom_id"
    else
        id=$(generate_id)
    fi

    # Determine file path (with optional subdirectory)
    local file
    if [[ -n "$dir" ]]; then
        mkdir -p "$TICKETS_DIR/$dir"
        file="$TICKETS_DIR/$dir/${id}.md"
    else
        file="$TICKETS_DIR/${id}.md"
    fi

    # Check for ID collision
    if [[ -f "$file" ]]; then
        echo "Error: ticket '$id' already exists" >&2
        return 1
    fi
    local now
    now=$(_iso_date)

    {
        echo "---"
        echo "id: $id"
        echo "status: open"
        echo "deps: []"
        echo "created: $now"
        echo "type: $issue_type"
        echo "priority: $priority"
        [[ -n "$assignee" ]] && echo "assignee: $assignee"
        [[ -n "$external_ref" ]] && echo "external-ref: $external_ref"
        echo "---"
        echo "# $title"
        echo ""
        if [[ -n "$description" ]]; then
            echo "$description"
            echo ""
        fi
        if [[ -n "$design" ]]; then
            echo "## Design"
            echo ""
            echo "$design"
            echo ""
        fi
        if [[ -n "$acceptance" ]]; then
            echo "## Acceptance Criteria"
            echo ""
            echo "$acceptance"
            echo ""
        fi
    } > "$file"

    echo "$id"
}

# Valid statuses
VALID_STATUSES="open in_progress closed"

validate_status() {
    local status="$1"
    for valid in $VALID_STATUSES; do
        [[ "$status" == "$valid" ]] && return 0
    done
    echo "Error: invalid status '$status'. Must be one of: $VALID_STATUSES" >&2
    return 1
}

cmd_status() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: $(basename "$0") status <id> <status>" >&2
        echo "Valid statuses: $VALID_STATUSES" >&2
        return 1
    fi

    local id="$1"
    local status="$2"

    validate_status "$status" || return 1

    local file
    file=$(ticket_path "$id") || return 1

    update_yaml_field "$file" "status" "$status"
    touch_updated "$file"
    echo "Updated $(basename "$file" .md) -> $status"
}

cmd_start() {
    if [[ $# -lt 1 ]]; then
        echo "Usage: $(basename "$0") start <id>" >&2
        return 1
    fi
    cmd_status "$1" "in_progress"
}

cmd_close() {
    if [[ $# -lt 1 ]]; then
        echo "Usage: $(basename "$0") close <id>" >&2
        return 1
    fi
    cmd_status "$1" "closed"
}

cmd_reopen() {
    if [[ $# -lt 1 ]]; then
        echo "Usage: $(basename "$0") reopen <id>" >&2
        return 1
    fi
    cmd_status "$1" "open"
}

cmd_dep_tree() {
    local full_mode=0
    local root_id=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full) full_mode=1; shift ;;
            *) root_id="$1"; shift ;;
        esac
    done

    if [[ -z "$root_id" ]]; then
        echo "Usage: ticket dep tree [--full] <id>" >&2
        return 1
    fi

    awk -v root_pattern="$root_id" -v full_mode="$full_mode" '
    BEGIN { FS=": "; in_front=0 }
    FNR==1 {
        if (prev_file) store()
        id=""; status=""; title=""; deps=""; in_front=0
        prev_file=FILENAME
    }
    /^---$/ { in_front = !in_front; next }
    in_front && /^id:/ { id = $2 }
    in_front && /^status:/ { status = $2 }
    in_front && /^deps:/ {
        deps = $2
        gsub(/[\[\] ]/, "", deps)
    }
    !in_front && /^# / && title == "" { title = substr($0, 3) }
    function store() {
        if (id != "") {
            statuses[id] = status
            titles[id] = title
            deps_str[id] = deps
            n = split(deps, arr, ",")
            for (i = 1; i <= n; i++) if (arr[i] != "") {
                dep_count[id]++
                dep_list[id, dep_count[id]] = arr[i]
            }
        }
    }

    END {
        if (prev_file) store()
        # Resolve partial ID
        root = ""
        for (id in statuses) {
            if (index(id, root_pattern) > 0) {
                if (root != "") {
                    print "Error: ambiguous ID " root_pattern > "/dev/stderr"
                    exit 1
                }
                root = id
            }
        }
        if (root == "") {
            print "Error: ticket " root_pattern " not found" > "/dev/stderr"
            exit 1
        }

        # Find max depths using iterative approach with stack
        stack[1] = root; stack_depth[1] = 0; stack_path[1] = ":"
        sp = 1
        while (sp > 0) {
            id = stack[sp]; depth = stack_depth[sp]; path = stack_path[sp]
            sp--

            if (!(id in statuses)) continue
            if (index(path, ":" id ":") > 0) continue

            if (!(id in max_depth) || depth > max_depth[id]) {
                max_depth[id] = depth
            }

            new_path = path id ":"
            for (i = dep_count[id]; i >= 1; i--) {
                child = dep_list[id, i]
                if (child != "") {
                    sp++
                    stack[sp] = child
                    stack_depth[sp] = depth + 1
                    stack_path[sp] = new_path
                }
            }
        }

        # Compute subtree depths (iterative post-order)
        delete stack; delete stack_depth; delete stack_path
        delete visited
        stack[1] = root; stack_path[1] = ":"; stack_phase[1] = 0
        sp = 1
        while (sp > 0) {
            id = stack[sp]; path = stack_path[sp]; phase = stack_phase[sp]

            if (!(id in statuses) || index(path, ":" id ":") > 0) { sp--; continue }

            if (phase == 0) {
                # First visit: push children
                stack_phase[sp] = 1
                new_path = path id ":"
                for (i = dep_count[id]; i >= 1; i--) {
                    child = dep_list[id, i]
                    if (child != "" && !(child in subtree_depth)) {
                        sp++
                        stack[sp] = child
                        stack_path[sp] = new_path
                        stack_phase[sp] = 0
                    }
                }
            } else {
                # Second visit: compute subtree depth
                max_sub = max_depth[id]
                for (i = 1; i <= dep_count[id]; i++) {
                    child = dep_list[id, i]
                    if (child in subtree_depth && subtree_depth[child] > max_sub) {
                        max_sub = subtree_depth[child]
                    }
                }
                subtree_depth[id] = max_sub
                sp--
            }
        }

        # Print tree (iterative with stack)
        print root " [" statuses[root] "] " titles[root]
        printed[root] = 1

        delete stack
        # Stack entries: id|depth|prefix|connector|path
        # Start with root children
        build_children(root, 0, "", "", ":" root ":")

        while (print_sp > 0) {
            id = print_stack_id[print_sp]
            depth = print_stack_depth[print_sp]
            prefix = print_stack_prefix[print_sp]
            connector = print_stack_conn[print_sp]
            path = print_stack_path[print_sp]
            print_sp--

            if (!(id in statuses)) continue
            if (!full_mode && (id in printed)) continue
            if (index(path, ":" id ":") > 0) continue
            if (!full_mode && depth != max_depth[id]) continue

            print prefix connector id " [" statuses[id] "] " titles[id]
            if (!full_mode) printed[id] = 1

            if (connector == "└── ") new_prefix = prefix "    "
            else new_prefix = prefix "│   "

            build_children(id, depth, new_prefix, connector, path id ":")
        }
    }

    function build_children(id, depth, prefix, connector, path,    i, child, n, arr, sorted, j, tmp, min_idx) {
        # Collect printable children
        n = 0
        for (i = 1; i <= dep_count[id]; i++) {
            child = dep_list[id, i]
            if (child == "") continue
            if (!full_mode && (child in printed)) continue
            if (!(child in max_depth)) continue
            if (!full_mode && depth + 1 != max_depth[child]) continue
            if (index(path, ":" child ":") > 0) continue
            n++
            arr[n] = child
        }
        if (n == 0) return

        # Sort by subtree_depth, then by ticket ID (insertion sort)
        for (i = 2; i <= n; i++) {
            tmp = arr[i]
            j = i - 1
            while (j >= 1 && (subtree_depth[arr[j]] > subtree_depth[tmp] || \
                   (subtree_depth[arr[j]] == subtree_depth[tmp] && arr[j] > tmp))) {
                arr[j + 1] = arr[j]
                j--
            }
            arr[j + 1] = tmp
        }

        # Push to stack in reverse order (so first prints first)
        for (i = n; i >= 1; i--) {
            child = arr[i]
            print_sp++
            print_stack_id[print_sp] = child
            print_stack_depth[print_sp] = depth + 1
            print_stack_prefix[print_sp] = prefix
            if (i == n) print_stack_conn[print_sp] = "└── "
            else print_stack_conn[print_sp] = "├── "
            print_stack_path[print_sp] = path
        }
    }
    ' "$TICKETS_DIR"/*.md 2>/dev/null
}

cmd_dep() {
    # Handle subcommands
    if [[ "${1:-}" == "tree" ]]; then
        shift
        cmd_dep_tree "$@"
        return
    fi

    if [[ $# -lt 2 ]]; then
        echo "Usage: ticket dep <id> <dependency-id>" >&2
        echo "       ticket dep tree <id>  - show dependency tree" >&2
        return 1
    fi

    local id="$1"
    local dep_id="$2"
    local file
    file=$(ticket_path "$id") || return 1

    # Verify dependency exists
    ticket_path "$dep_id" >/dev/null || return 1

    # Get current deps
    local current_deps
    current_deps=$(yaml_field "$file" "deps")

    # Add dep if not already present
    if echo "$current_deps" | _grep -q "$dep_id"; then
        echo "Dependency already exists"
        return 0
    fi

    # Update deps array
    if [[ "$current_deps" == "[]" ]]; then
        update_yaml_field "$file" "deps" "[$dep_id]"
    else
        local new_deps
        new_deps=$(echo "$current_deps" | sed "s/\]/, $dep_id]/")
        update_yaml_field "$file" "deps" "$new_deps"
    fi

    touch_updated "$file"
    echo "Added dependency: $(basename "$file" .md) -> $dep_id"
}

cmd_ls() {
    [[ ! -d "$TICKETS_DIR" ]] && return 0

    local status_filter="" tag_filter="" dir_filter="" summary_mode=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status=*) status_filter="${1#--status=}"; shift ;;
            --status) shift; [[ $# -gt 0 ]] && { status_filter="$1"; shift; } ;;
            --tag=*) tag_filter="${1#--tag=}"; shift ;;
            --tag) shift; [[ $# -gt 0 ]] && { tag_filter="$1"; shift; } ;;
            --dir=*) dir_filter="${1#--dir=}"; shift ;;
            --dir) shift; [[ $# -gt 0 ]] && { dir_filter="$1"; shift; } ;;
            --summary) summary_mode=1; shift ;;
            *) shift ;;
        esac
    done

    # Build file list
    local files
    if [[ -n "$dir_filter" ]]; then
        files=$(find "$TICKETS_DIR/$dir_filter" -maxdepth 1 -name "*.md" 2>/dev/null)
    else
        files=$(find "$TICKETS_DIR" -name "*.md" 2>/dev/null)
    fi
    [[ -z "$files" ]] && return 0

    if [[ $summary_mode -eq 1 ]]; then
        # Summary mode: show directory progress
        echo "$files" | xargs awk -v tickets_dir="$TICKETS_DIR" '
        BEGIN { FS=": "; in_front=0 }
        FNR==1 {
            if (prev_file) store()
            id=""; status=""; in_front=0
            prev_file=FILENAME
            # Extract directory from path
            dir = FILENAME
            sub(tickets_dir "/", "", dir)
            # Check if there is a subdirectory (contains /)
            if (index(dir, "/") > 0) {
                sub(/\/[^\/]+$/, "", dir)
            } else {
                dir = "(root)"
            }
            current_dir = dir
        }
        /^---$/ { in_front = !in_front; next }
        in_front && /^id:/ { id = $2 }
        in_front && /^status:/ { status = $2 }
        function store() {
            if (id != "") {
                total[current_dir]++
                if (status == "closed") closed[current_dir]++
                else if (status == "in_progress") in_prog[current_dir]++
                else open_count[current_dir]++
            }
        }
        END {
            if (prev_file) store()
            for (dir in total) {
                c = closed[dir]+0
                t = total[dir]
                o = open_count[dir]+0
                p = in_prog[dir]+0
                pct = (t > 0) ? int(c * 100 / t) : 0
                printf "%-20s %d/%d (%d%%)  [%d open, %d in progress]\n", dir, c, t, pct, o, p
            }
        }
        '
    else
        # Normal list mode
        echo "$files" | xargs awk -v status_filter="$status_filter" -v tag_filter="$tag_filter" '
        BEGIN { FS=": "; in_front=0 }
        FNR==1 {
            if (prev_file) emit()
            id=""; status=""; title=""; deps=""; tags=""; in_front=0
            prev_file=FILENAME
        }
        /^---$/ { in_front = !in_front; next }
        in_front && /^id:/ { id = $2 }
        in_front && /^status:/ { status = $2 }
        in_front && /^deps:/ {
            deps = $2
            gsub(/[\[\] ]/, "", deps)
        }
        in_front && /^tags:/ {
            tags = $2
            gsub(/[\[\] ]/, "", tags)
        }
        !in_front && /^# / && title == "" { title = substr($0, 3) }
        END { if (prev_file) emit() }
        function glob_match(str, pattern,    regex) {
            if (pattern == "") return 1
            regex = pattern
            gsub(/\*/, ".*", regex)
            gsub(/\?/, ".", regex)
            return match(str, "^" regex "$")
        }
        function has_matching_tag(tags_str, pattern,    i, n, arr) {
            if (pattern == "") return 1
            if (tags_str == "") return 0
            n = split(tags_str, arr, ",")
            for (i = 1; i <= n; i++) {
                if (glob_match(arr[i], pattern)) return 1
            }
            return 0
        }
        function emit() {
            if (id == "") return
            if (status_filter != "" && status != status_filter) return
            if (!has_matching_tag(tags, tag_filter)) return

            deps_display = (deps != "") ? "[" deps "]" : "[]"
            gsub(/,/, ", ", deps_display)
            dep_str = (deps_display != "[]") ? " <- " deps_display : ""
            printf "%-8s [%s] - %s%s\n", id, status, title, dep_str
        }
        '
    fi
}

cmd_ready() {
    [[ ! -d "$TICKETS_DIR" ]] && return 0

    local show_tags=0 group_mode=0 group_pattern="" dir_filter=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tags) show_tags=1; shift ;;
            --group=*) group_mode=1; group_pattern="${1#--group=}"; shift ;;
            --group) group_mode=1; shift; [[ $# -gt 0 && "$1" != --* ]] && { group_pattern="$1"; shift; } ;;
            --dir=*) dir_filter="${1#--dir=}"; shift ;;
            --dir) shift; [[ $# -gt 0 ]] && { dir_filter="$1"; shift; } ;;
            *) shift ;;
        esac
    done

    # Build file list
    local files
    if [[ -n "$dir_filter" ]]; then
        files=$(find "$TICKETS_DIR/$dir_filter" -maxdepth 1 -name "*.md" 2>/dev/null)
    else
        files=$(find "$TICKETS_DIR" -name "*.md" 2>/dev/null)
    fi
    [[ -z "$files" ]] && return 0

    echo "$files" | xargs awk -v show_tags="$show_tags" -v group_mode="$group_mode" -v group_pattern="$group_pattern" '
    BEGIN { FS=": "; in_front=0 }
    FNR==1 {
        if (prev_file) store()
        id=""; status=""; title=""; deps=""; priority=""; tags=""; in_front=0
        prev_file=FILENAME
    }
    /^---$/ { in_front = !in_front; next }
    in_front && /^id:/ { id = $2 }
    in_front && /^status:/ { status = $2 }
    in_front && /^priority:/ { priority = $2 }
    in_front && /^deps:/ {
        deps = $2
        gsub(/[\[\] ]/, "", deps)
    }
    in_front && /^tags:/ {
        tags = $2
        gsub(/[\[\] ]/, "", tags)
    }
    !in_front && /^# / && title == "" { title = substr($0, 3) }
    function store() {
        if (id != "") {
            statuses[id] = status
            titles[id] = title
            deps_raw[id] = deps
            priorities[id] = (priority != "") ? priority : 2
            tags_raw[id] = tags
        }
    }
    function glob_match(str, pattern,    regex) {
        if (pattern == "") return 1
        regex = pattern
        gsub(/\*/, ".*", regex)
        gsub(/\?/, ".", regex)
        return match(str, "^" regex "$")
    }
    END {
        if (prev_file) store()
        # Find ready tickets: active with all deps closed
        for (id in statuses) {
            status = statuses[id]
            if (status != "open" && status != "in_progress") continue

            deps = deps_raw[id]
            ready = 1
            if (deps != "") {
                n = split(deps, arr, ",")
                for (i = 1; i <= n; i++) {
                    dep = arr[i]
                    if (dep != "" && statuses[dep] != "closed") {
                        ready = 0
                        break
                    }
                }
            }
            if (ready) {
                ready_ids[++ready_count] = id
            }
        }

        # Sort ready tickets by priority, then by id
        for (i = 1; i <= ready_count; i++) {
            for (j = i + 1; j <= ready_count; j++) {
                id_i = ready_ids[i]; id_j = ready_ids[j]
                if (priorities[id_i] > priorities[id_j] || \
                    (priorities[id_i] == priorities[id_j] && id_i > id_j)) {
                    ready_ids[i] = id_j; ready_ids[j] = id_i
                }
            }
        }

        if (group_mode) {
            # Collect all tags from ready tickets, filtering by pattern
            for (i = 1; i <= ready_count; i++) {
                id = ready_ids[i]
                tags = tags_raw[id]
                if (tags == "") {
                    if (group_pattern == "" || glob_match("untagged", group_pattern)) {
                        tag_tickets["untagged", ++tag_count["untagged"]] = id
                    }
                } else {
                    n = split(tags, arr, ",")
                    for (j = 1; j <= n; j++) {
                        tag = arr[j]
                        if (glob_match(tag, group_pattern)) {
                            tag_tickets[tag, ++tag_count[tag]] = id
                        }
                    }
                }
            }

            # Collect and sort tag names
            for (tag in tag_count) {
                all_tags[++num_tags] = tag
            }
            for (i = 1; i <= num_tags; i++) {
                for (j = i + 1; j <= num_tags; j++) {
                    if (all_tags[i] > all_tags[j]) {
                        tmp = all_tags[i]; all_tags[i] = all_tags[j]; all_tags[j] = tmp
                    }
                }
            }

            # Print grouped output
            for (i = 1; i <= num_tags; i++) {
                tag = all_tags[i]
                printf "\n## %s\n", tag
                for (j = 1; j <= tag_count[tag]; j++) {
                    id = tag_tickets[tag, j]
                    printf "%-8s [P%s][%s] - %s\n", id, priorities[id], statuses[id], titles[id]
                }
            }
        } else {
            # Standard output
            for (i = 1; i <= ready_count; i++) {
                id = ready_ids[i]
                if (show_tags && tags_raw[id] != "") {
                    printf "%-8s [P%s][%s] - %s [%s]\n", id, priorities[id], statuses[id], titles[id], tags_raw[id]
                } else {
                    printf "%-8s [P%s][%s] - %s\n", id, priorities[id], statuses[id], titles[id]
                }
            }
        }
    }
    '
}

cmd_closed() {
    [[ ! -d "$TICKETS_DIR" ]] && return 0

    local limit=20
    for arg in "$@"; do
        case "$arg" in
            --limit=*) limit="${arg#--limit=}" ;;
        esac
    done

    # List files by mtime (most recent first), filter closed, limit output
    local files
    files=$(ls -t "$TICKETS_DIR"/*.md 2>/dev/null | head -n 100)
    [[ -z "$files" ]] && return 0
    echo "$files" | xargs awk '
    BEGIN { FS=": "; in_front=0 }
    FNR==1 {
        if (prev_file) emit()
        id=""; status=""; title=""; in_front=0
        prev_file=FILENAME
    }
    /^---$/ { in_front = !in_front; next }
    in_front && /^id:/ { id = $2 }
    in_front && /^status:/ { status = $2 }
    !in_front && /^# / && title == "" { title = substr($0, 3) }
    function emit() {
        if (id != "" && (status == "closed" || status == "done")) {
            output[++count] = sprintf("%-8s [%s] - %s", id, status, title)
        }
    }
    END {
        if (prev_file) emit()
        for (i = 1; i <= count; i++) print output[i]
    }
    ' | head -n "$limit"
}

cmd_blocked() {
    [[ ! -d "$TICKETS_DIR" ]] && return 0

    awk '
    BEGIN { FS=": "; in_front=0 }
    FNR==1 {
        if (prev_file) store()
        id=""; status=""; title=""; deps=""; priority=""; in_front=0
        prev_file=FILENAME
    }
    /^---$/ { in_front = !in_front; next }
    in_front && /^id:/ { id = $2 }
    in_front && /^status:/ { status = $2 }
    in_front && /^priority:/ { priority = $2 }
    in_front && /^deps:/ {
        deps = $2
        gsub(/[\[\] ]/, "", deps)
    }
    !in_front && /^# / && title == "" { title = substr($0, 3) }
    function store() {
        if (id != "") {
            statuses[id] = status
            titles[id] = title
            deps_raw[id] = deps
            priorities[id] = (priority != "") ? priority : 2
        }
    }
    END {
        if (prev_file) store()
        # Find blocked tickets: active with at least one dep not closed
        for (id in statuses) {
            status = statuses[id]
            if (status != "open" && status != "in_progress") continue

            deps = deps_raw[id]
            if (deps == "") continue

            blocked = 0
            n = split(deps, arr, ",")
            for (i = 1; i <= n; i++) {
                dep = arr[i]
                if (dep != "" && statuses[dep] != "closed") {
                    blocked = 1
                    break
                }
            }
            if (blocked) {
                # Build list of only open blockers
                blockers = ""
                n = split(deps, arr, ",")
                for (i = 1; i <= n; i++) {
                    dep = arr[i]
                    if (dep != "" && statuses[dep] != "closed") {
                        blockers = (blockers == "") ? dep : blockers ", " dep
                    }
                }
                output[++count] = sprintf("%s|%s|%s|%s|[%s]", priorities[id], id, status, titles[id], blockers)
            }
        }

        # Sort by priority, then by id
        for (i = 1; i <= count; i++) {
            for (j = i + 1; j <= count; j++) {
                split(output[i], a, "|")
                split(output[j], b, "|")
                if (a[1] > b[1] || (a[1] == b[1] && a[2] > b[2])) {
                    tmp = output[i]; output[i] = output[j]; output[j] = tmp
                }
            }
        }

        for (i = 1; i <= count; i++) {
            split(output[i], f, "|")
            printf "%-8s [P%s][%s] - %s <- %s\n", f[2], f[1], f[3], f[4], f[5]
        }
    }
    ' "$TICKETS_DIR"/*.md 2>/dev/null
}

cmd_tag() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: ticket tag <id> <tag> [tag...]" >&2
        return 1
    fi

    local id="$1"
    shift
    local file
    file=$(ticket_path "$id") || return 1

    local current_tags
    current_tags=$(yaml_field "$file" "tags")
    [[ -z "$current_tags" ]] && current_tags="[]"

    for tag in "$@"; do
        if echo "$current_tags" | _grep -q "$tag"; then
            echo "Tag '$tag' already exists"
            continue
        fi

        if [[ "$current_tags" == "[]" ]]; then
            current_tags="[$tag]"
        else
            current_tags=$(echo "$current_tags" | sed "s/\]/, $tag]/")
        fi
        echo "Added tag: $(basename "$file" .md) + $tag"
    done

    update_yaml_field "$file" "tags" "$current_tags"
    touch_updated "$file"
}

cmd_untag() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: ticket untag <id> <tag> [tag...]" >&2
        return 1
    fi

    local id="$1"
    shift
    local file
    file=$(ticket_path "$id") || return 1

    local current_tags
    current_tags=$(yaml_field "$file" "tags")
    [[ -z "$current_tags" ]] && current_tags="[]"

    for tag in "$@"; do
        if ! echo "$current_tags" | _grep -q "$tag"; then
            echo "Tag '$tag' not found"
            continue
        fi

        current_tags=$(echo "$current_tags" | sed "s/, *$tag//g; s/$tag, *//g; s/$tag//g")
        [[ "$current_tags" == "[]" || "$current_tags" == "[, ]" || "$current_tags" == "[ ]" ]] && current_tags="[]"
        echo "Removed tag: $(basename "$file" .md) - $tag"
    done

    update_yaml_field "$file" "tags" "$current_tags"
    touch_updated "$file"
}

cmd_tags() {
    [[ ! -d "$TICKETS_DIR" ]] && return 0

    awk '
    BEGIN { FS=": "; in_front=0 }
    FNR==1 {
        if (prev_file) store()
        status=""; tags=""; in_front=0
        prev_file=FILENAME
    }
    /^---$/ { in_front = !in_front; next }
    in_front && /^status:/ { status = $2 }
    in_front && /^tags:/ {
        tags = $2
        gsub(/[\[\] ]/, "", tags)
    }
    function store() {
        if (status != "closed" && tags != "") {
            n = split(tags, arr, ",")
            for (i = 1; i <= n; i++) {
                if (arr[i] != "") all_tags[arr[i]]++
            }
        }
    }
    END {
        if (prev_file) store()
        for (tag in all_tags) {
            output[++count] = tag
        }
        # Sort alphabetically
        for (i = 1; i <= count; i++) {
            for (j = i + 1; j <= count; j++) {
                if (output[i] > output[j]) {
                    tmp = output[i]; output[i] = output[j]; output[j] = tmp
                }
            }
        }
        for (i = 1; i <= count; i++) {
            printf "%s (%d)\n", output[i], all_tags[output[i]]
        }
    }
    ' "$TICKETS_DIR"/*.md 2>/dev/null
}

cmd_undep() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: ticket undep <id> <dependency-id>" >&2
        return 1
    fi

    local id="$1"
    local dep_id="$2"
    local file
    file=$(ticket_path "$id") || return 1

    local current_deps
    current_deps=$(yaml_field "$file" "deps")

    if ! echo "$current_deps" | _grep -q "$dep_id"; then
        echo "Dependency not found"
        return 1
    fi

    # Remove dep from array
    local new_deps
    new_deps=$(echo "$current_deps" | sed "s/, *$dep_id//g; s/$dep_id, *//g; s/$dep_id//g")
    # Clean up empty array case
    [[ "$new_deps" == "[]" || "$new_deps" == "[, ]" || "$new_deps" == "[ ]" ]] && new_deps="[]"

    update_yaml_field "$file" "deps" "$new_deps"
    touch_updated "$file"
    echo "Removed dependency: $(basename "$file" .md) -/-> $dep_id"
}

cmd_show() {
    if [[ $# -lt 1 ]]; then
        echo "Usage: ticket show <id>" >&2
        return 1
    fi

    local file
    file=$(ticket_path "$1") || return 1
    cat "$file"
}

cmd_edit() {
    if [[ $# -lt 1 ]]; then
        echo "Usage: ticket edit <id>" >&2
        return 1
    fi

    local file
    file=$(ticket_path "$1") || return 1
    "${EDITOR:-vi}" "$file"
}

cmd_add_note() {
    if [[ $# -lt 1 ]]; then
        echo "Usage: ticket add-note <id> [text]" >&2
        return 1
    fi

    local file
    file=$(ticket_path "$1") || return 1
    shift

    local note
    if [[ $# -gt 0 ]]; then
        note="$*"
    else
        note=$(cat)
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%d %H:%M UTC")

    printf '\n**%s:** %s\n' "$timestamp" "$note" >> "$file"
}

cmd_query() {
    [[ ! -d "$TICKETS_DIR" ]] && return 0

    local filter="${1:-}"

    # Generate all JSON in one awk pass
    local json_output
    json_output=$(awk '
    BEGIN { FS=": "; in_front=0 }
    FNR==1 {
        if (prev_file) emit()
        field_count=0; in_front=0
        prev_file=FILENAME
    }
    /^---$/ { in_front = !in_front; next }
    in_front && /^[a-zA-Z]/ {
        key = $1
        val = substr($0, length($1) + 3)
        gsub(/^ +| +$/, "", val)
        field_count++
        field_keys[field_count] = key
        field_vals[field_count] = val
    }
    function emit() {
        if (field_count > 0) {
            printf "{"
            for (i = 1; i <= field_count; i++) {
                if (i > 1) printf ","
                key = field_keys[i]
                val = field_vals[i]
                # Handle arrays
                if (val ~ /^\[.*\]$/) {
                    gsub(/^\[|\]$/, "", val)
                    n = split(val, items, ", *")
                    printf "\"%s\":[", key
                    for (j = 1; j <= n; j++) {
                        if (j > 1) printf ","
                        gsub(/^ +| +$/, "", items[j])
                        if (items[j] != "") printf "\"%s\"", items[j]
                    }
                    printf "]"
                } else {
                    printf "\"%s\":\"%s\"", key, val
                }
            }
            printf "}\n"
        }
    }
    END { if (prev_file) emit() }
    ' "$TICKETS_DIR"/*.md 2>/dev/null)

    if [[ -n "$filter" ]]; then
        echo "$json_output" | jq -c "select($filter)"
    else
        echo "$json_output"
    fi
}

cmd_migrate_beads() {
    local jsonl=".beads/issues.jsonl"
    if [[ ! -f "$jsonl" ]]; then
        echo "Error: $jsonl not found" >&2
        return 1
    fi

    if ! command -v jq &>/dev/null; then
        echo "Error: jq is required for migration" >&2
        return 1
    fi

    ensure_dir

    # Single jq call generates all markdown with <<<FILE:id>>> delimiters
    # Then awk splits into individual files (much faster than per-line jq calls)
    jq -r '
        def deps_array:
            [.dependencies[]?.depends_on_id // empty]
            | if length == 0 then "[]"
              else "[" + (map("\(.)") | join(", ")) + "]" end;

        "<<<FILE:\(.id)>>>\n" +
        "---\n" +
        "id: \(.id)\n" +
        "status: \(.status // "open")\n" +
        "deps: \(deps_array)\n" +
        "created: \(.created_at // "")\n" +
        "type: \(.issue_type // "task")\n" +
        "priority: \(.priority // 2)\n" +
        (if .assignee and .assignee != "" then "assignee: \(.assignee)\n" else "" end) +
        (if .external_ref and .external_ref != "" then "external-ref: \(.external_ref)\n" else "" end) +
        "---\n" +
        "# \(.title // "Untitled")\n\n" +
        (if .description and .description != "" then "\(.description)\n\n" else "" end) +
        (if .design and .design != "" then "## Design\n\n\(.design)\n\n" else "" end) +
        (if .acceptance_criteria and .acceptance_criteria != "" then "## Acceptance Criteria\n\n\(.acceptance_criteria)\n\n" else "" end) +
        (if .notes and .notes != "" then "## Notes\n\n\(.notes)\n\n" else "" end)
    ' "$jsonl" | awk -v dir="$TICKETS_DIR" '
        /^<<<FILE:.*>>>$/ {
            if (file) close(file)
            id = substr($0, 9, length($0) - 11)
            file = dir "/" id ".md"
            count++
            print "Migrated: " id
            next
        }
        file { print > file }
        END { if (file) close(file); print "Migrated " count " tickets from beads" }
    '
}

cmd_help() {
    local cmd
    cmd=$(basename "$0")
    cat << EOF
$cmd - minimal ticket system with dependency tracking

Usage: $cmd <command> [args]

Commands:
  create [title] [options] Create ticket, prints ID
    -d, --description      Description text
    --design               Design notes
    --acceptance           Acceptance criteria
    -t, --type             Type (bug|feature|task|epic|chore) [default: task]
    -p, --priority         Priority 0-4, 0=highest [default: 2]
    -a, --assignee         Assignee
    --external-ref         External reference (e.g., gh-123, JIRA-456)
    --id ID                Custom ticket ID (default: auto-generated)
    --dir DIR              Create in subdirectory (e.g., --dir pipeline-v2)
  start <id>               Set status to in_progress
  close <id>               Set status to closed
  reopen <id>              Set status to open
  status <id> <status>     Update status (open|in_progress|closed)
  dep <id> <dep-id>        Add dependency (id depends on dep-id)
  dep tree [--full] <id>   Show dependency tree (--full disables dedup)
  undep <id> <dep-id>      Remove dependency
  tag <id> <tag> [...]     Add tag(s) to ticket
  untag <id> <tag> [...]   Remove tag(s) from ticket
  tags                     List tags in use by open tickets
  ls [options]             List tickets
    --status=X             Filter by status
    --tag=PATTERN          Filter by tag (supports wildcards: 'size-*')
    --dir=DIR              Filter by subdirectory
    --summary              Show directory progress summary
  ready [options]          List open/in-progress tickets with deps resolved
    --tags                 Show tags for each ticket
    --group[=PATTERN]      Group by tag (optionally filter tags: --group='size-*')
    --dir=DIR              Filter by subdirectory
  blocked                  List open/in-progress tickets with unresolved deps
  closed [--limit=N]       List recently closed tickets (default 20, by mtime)
  show <id>                Display ticket
  edit <id>                Open ticket in \$EDITOR
  add-note <id> [text]     Append timestamped note (or pipe via stdin)
  query [jq-filter]        Output tickets as JSON, optionally filtered
  migrate-beads            Import tickets from .beads/issues.jsonl

Tickets stored as markdown files in .tickets/ (use --dir to organize into subdirectories)
You can also manually move tickets into directories - ID resolution searches all subdirs
Supports partial ID matching (e.g., '$cmd show 5c4' matches 'nw-5c46')
EOF
}

# Main dispatch
case "${1:-help}" in
    create|add|new) shift; cmd_create "$@" ;;
    start)  shift; cmd_start "$@" ;;
    close)  shift; cmd_close "$@" ;;
    reopen) shift; cmd_reopen "$@" ;;
    status) shift; cmd_status "$@" ;;
    dep)    shift; cmd_dep "$@" ;;
    undep)  shift; cmd_undep "$@" ;;
    tag)    shift; cmd_tag "$@" ;;
    untag)  shift; cmd_untag "$@" ;;
    tags)   cmd_tags ;;
    ls)     shift; cmd_ls "$@" ;;
    ready)  shift; cmd_ready "$@" ;;
    blocked) cmd_blocked ;;
    closed) shift; cmd_closed "$@" ;;
    show)   shift; cmd_show "$@" ;;
    edit)   shift; cmd_edit "$@" ;;
    add-note) shift; cmd_add_note "$@" ;;
    query) shift; cmd_query "$@" ;;
    migrate-beads) shift; cmd_migrate_beads "$@" ;;
    help|--help|-h) cmd_help ;;
    *)
        echo "Unknown command: $1" >&2
        cmd_help >&2
        exit 1
        ;;
esac
